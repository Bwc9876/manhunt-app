/* eslint @typescript-eslint/no-unused-vars: 0 */
/* eslint @typescript-eslint/no-explicit-any: 0 */
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
    /**
     * (Screen: Menu) Start/Join a new lobby, set `join_code` to `null` to be host,
     * set it to a join code to be a client. This triggers a screen change to [AppScreen::Lobby]
     */
    async startLobby(
        joinCode: string | null,
        settings: GameSettings
    ): Promise<Result<null, string>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("start_lobby", { joinCode, settings })
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Menu) Get the user's player profile
     */
    async getProfile(): Promise<Result<PlayerProfile, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_profile") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Quit a running game or leave a lobby
     */
    async quitToMenu(): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("quit_to_menu") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Get the screen the app should currently be on, returns [AppScreen]
     */
    async getCurrentScreen(): Promise<Result<AppScreen, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_current_screen") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Menu) Update the player's profile and persist it
     */
    async updateProfile(newProfile: PlayerProfile): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("update_profile", { newProfile }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Lobby) Get the current state of the lobby, call after receiving an update event
     */
    async getLobbyState(): Promise<Result<LobbyState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_lobby_state") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Lobby) HOST ONLY: Push new settings to everyone, does nothing on clients. Returns the
     * new lobby state
     */
    async hostUpdateSettings(settings: GameSettings): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("host_update_settings", { settings }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Lobby) Switch teams between seekers and hiders, returns the new [LobbyState]
     */
    async switchTeams(seeker: boolean): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("switch_teams", { seeker }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Lobby) HOST ONLY: Start the game, stops anyone else from joining and switched screen
     * to AppScreen::Game.
     */
    async hostStartGame(): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("host_start_game") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Mark this player as caught, this player will become a seeker. Returns the new game state
     */
    async markCaught(): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("mark_caught") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Grab a powerup on the map, this should be called when the user is *in range* of
     * the powerup. Returns the new game state after rolling for the powerup
     */
    async grabPowerup(): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("grab_powerup") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Use the currently held powerup in the player's held_powerup. Does nothing if the
     * player has none. Returns the updated game state
     */
    async usePowerup(): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("use_powerup") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Menu) Check if a room code is valid to join, use this before starting a game
     * for faster error checking.
     */
    async checkRoomCode(code: string): Promise<Result<boolean, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("check_room_code", { code }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Get all player profiles with display names and profile pictures for this game.
     * This value will never change and is fairly expensive to clone, so please minimize calls to
     * this command.
     */
    async getProfiles(): Promise<Result<Partial<{ [key in string]: PlayerProfile }>, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_profiles") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Menu) Go to the game replay screen to replay the game history specified by id
     */
    async replayGame(id: string): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("replay_game", { id }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Menu) Get a list of all previously played games, returns of list of DateTimes that represent when
     * each game started, use this as a key
     */
    async listGameHistories(): Promise<Result<string[], string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("list_game_histories") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Replay) Get the game history that's currently being replayed. Try to limit calls to
     * this
     */
    async getCurrentReplayHistory(): Promise<Result<AppGameHistory, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_current_replay_history") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Get the current settings for this game.
     */
    async getGameSettings(): Promise<Result<GameSettings, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_game_settings") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Get the current state of the game.
     */
    async getGameState(): Promise<Result<GameUiState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_game_state") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Setup) Complete user setup and go to the menu screen
     */
    async completeSetup(profile: PlayerProfile): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("complete_setup", { profile }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    }
};

/** user-defined events **/

export const events = __makeEvents__<{
    changeScreen: ChangeScreen;
    gameStateUpdate: GameStateUpdate;
    lobbyStateUpdate: LobbyStateUpdate;
}>({
    changeScreen: "change-screen",
    gameStateUpdate: "game-state-update",
    lobbyStateUpdate: "lobby-state-update"
});

/** user-defined constants **/

/** user-defined types **/

export type AppGameHistory = {
    history: GameHistory;
    profiles: Partial<{ [key in string]: PlayerProfile }>;
};
export type AppScreen = "Setup" | "Menu" | "Lobby" | "Game" | "Replay";
/**
 * The app is changing screens, contains the screen it's switching to
 */
export type ChangeScreen = AppScreen;
/**
 * An event used between players to update state
 */
export type GameEvent =
    /**
     * A player has been caught and is now a seeker, contains the ID of the caught player
     */
    | { PlayerCaught: string }
    /**
     * Public ping from a player revealing location
     */
    | { Ping: PlayerPing }
    /**
     * Force the player specified in `0` to ping, optionally display the ping as from the user
     * specified in `1`.
     */
    | { ForcePing: [string, string | null] }
    /**
     * Force a powerup to despawn because a player got it, contains the player that got it.
     */
    | { PowerupDespawn: string }
    /**
     * Contains location history of the given player, used after the game to sync location
     * histories
     */
    | { PostGameSync: [string, [string, Location][]] }
    /**
     * A player has been disconnected and removed from the game (because of error or otherwise).
     * The player should be removed from all state
     */
    | { DroppedPlayer: string }
    /**
     * The underlying transport has disconnected
     */
    | "TransportDisconnect";
export type GameHistory = {
    my_id: string;
    game_started: string;
    game_ended: string;
    events: [string, GameEvent][];
    locations: [string, [string, Location][]][];
};
/**
 * Settings for the game, host is the only person able to change these
 */
export type GameSettings = {
    /**
     * The random seed used for shared rng
     */
    random_seed: number;
    /**
     * The number of seconds to wait before seekers are allowed to go
     */
    hiding_time_seconds: number;
    /**
     * Condition to wait for global pings to begin
     */
    ping_start: PingStartCondition;
    /**
     * Time between pings after the condition is met (first ping is either after the interval or
     * instantly after the condition is met depending on the condition)
     */
    ping_minutes_interval: number;
    /**
     * Condition for powerups to start spawning
     */
    powerup_start: PingStartCondition;
    /**
     * Chance every minute of a powerup spawning, out of 100
     */
    powerup_chance: number;
    /**
     * Hard cooldown between powerups spawning
     */
    powerup_minutes_cooldown: number;
    /**
     * Locations that powerups may spawn at
     */
    powerup_locations: Location[];
};
/**
 * The state of the game has updated in some way, you're expected to call [get_game_state] when
 * receiving this
 */
export type GameStateUpdate = null;
/**
 * Subset of [GameState] that is meant to be sent to a UI frontend
 */
export type GameUiState = {
    /**
     * ID of the local player
     */
    my_id: string;
    /**
     * A map of player IDs to whether that player is a seeker
     */
    caught_state: Partial<{ [key in string]: boolean }>;
    /**
     * A powerup that is available on the map
     */
    available_powerup: Location | null;
    /**
     * A map of player IDs to an active ping on them
     */
    pings: Partial<{ [key in string]: PlayerPing }>;
    /**
     * When the game was started **in UTC**
     */
    game_started: string;
    /**
     * When the game ended, when this is Option::Some, the game has ended
     */
    game_ended: string | null;
    /**
     * The last time all hiders were pinged **in UTC**
     */
    last_global_ping: string | null;
    /**
     * The [PowerUpType] the local player is holding
     */
    held_powerup: PowerUpType | null;
    /**
     * When the seekers were allowed to start **in UTC**
     */
    seekers_started: string | null;
};
export type LobbyState = {
    profiles: Partial<{ [key in string]: PlayerProfile }>;
    join_code: string;
    /**
     * True represents seeker, false hider
     */
    teams: Partial<{ [key in string]: boolean }>;
    self_id: string | null;
    self_seeker: boolean;
    is_host: boolean;
    settings: GameSettings;
};
/**
 * The lobby state has updated in some way, you're expected to call [get_lobby_state] after
 * receiving this
 */
export type LobbyStateUpdate = null;
/**
 * Some location in the world as gotten from a Geolocation API
 */
export type Location = {
    /**
     * Latitude
     */
    lat: number;
    /**
     * Longitude
     */
    long: number;
    /**
     * The bearing (float normalized from 0 to 1) optional as GPS can't always determine
     */
    heading: number | null;
};
/**
 * The starting condition for global pings to begin
 */
export type PingStartCondition =
    /**
     * Wait For X players to be caught before beginning global pings
     */
    | { Players: number }
    /**
     * Wait for X minutes after game start to begin global pings
     */
    | { Minutes: number }
    /**
     * Don't wait at all, ping location after seekers are released
     */
    | "Instant";
/**
 * An on-map ping of a player
 */
export type PlayerPing = {
    /**
     * Location of the ping
     */
    loc: Location;
    /**
     * Time the ping happened
     */
    timestamp: string;
    /**
     * The player to display as
     */
    display_player: string;
    /**
     * The actual player that initialized this ping
     */
    real_player: string;
};
export type PlayerProfile = { display_name: string; pfp_base64: string | null };
/**
 * Type of powerup
 */
export type PowerUpType =
    /**
     * Ping a random seeker instead of a hider
     */
    | "PingSeeker"
    /**
     * Pings all seekers locations on the map for hiders
     */
    | "PingAllSeekers"
    /**
     * Ping another random hider instantly
     */
    | "ForcePingOther";

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE, Channel as TAURI_CHANNEL } from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
    listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
    once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
    emit: null extends T
        ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
        : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> = { status: "ok"; data: T } | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
    return new Proxy(
        {} as unknown as {
            [K in keyof T]: __EventObj__<T[K]> & {
                (handle: __WebviewWindow__): __EventObj__<T[K]>;
            };
        },
        {
            get: (_, event) => {
                const name = mappings[event as keyof T];

                return new Proxy((() => {}) as any, {
                    apply: (_, __, [window]: [__WebviewWindow__]) => ({
                        listen: (arg: any) => window.listen(name, arg),
                        once: (arg: any) => window.once(name, arg),
                        emit: (arg: any) => window.emit(name, arg)
                    }),
                    get: (_, command: keyof __EventObj__<any>) => {
                        switch (command) {
                            case "listen":
                                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
                            case "once":
                                return (arg: any) => TAURI_API_EVENT.once(name, arg);
                            case "emit":
                                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
                        }
                    }
                });
            }
        }
    );
}
