/* eslint @typescript-eslint/no-unused-vars: 0 */
/* eslint @typescript-eslint/no-explicit-any: 0 */
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
    /**
     * (Screen: Menu) Start/Join a new lobby, set `join_code` to `null` to be host,
     * set it to a join code to be a client. This triggers a screen change to [AppScreen::Lobby]
     */
    async startLobby(
        joinCode: string | null,
        settings: GameSettings
    ): Promise<Result<null, string>> {
        try {
            return {
                status: "ok",
                data: await TAURI_INVOKE("start_lobby", { joinCode, settings })
            };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Menu) Get the user's player profile
     */
    async getProfile(): Promise<Result<PlayerProfile, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_profile") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Quit a running game or leave a lobby
     */
    async quitGameOrLobby(): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("quit_game_or_lobby") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * Get the screen the app should currently be on, returns [AppScreen]
     */
    async getCurrentScreen(): Promise<Result<AppScreen, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_current_screen") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Menu) Update the player's profile and persist it
     */
    async updateProfile(newProfile: PlayerProfile): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("update_profile", { newProfile }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Lobby) Get the current state of the lobby, call after receiving an update event
     */
    async getLobbyState(): Promise<Result<LobbyState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("get_lobby_state") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Lobby) HOST ONLY: Push new settings to everyone, does nothing on clients. Returns the
     * new lobby state
     */
    async hostUpdateSettings(settings: GameSettings): Promise<Result<LobbyState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("host_update_settings", { settings }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Lobby) Switch teams between seekers and hiders, returns the new [LobbyState]
     */
    async switchTeams(seeker: boolean): Promise<Result<LobbyState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("switch_teams", { seeker }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Lobby) HOST ONLY: Start the game, stops anyone else from joining and switched screen
     * to AppScreen::Game.
     */
    async hostStartGame(): Promise<Result<null, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("host_start_game") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Mark this player as caught, this player will become a seeker. Returns the new game state
     */
    async markCaught(): Promise<Result<GameState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("mark_caught") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Grab a powerup on the map, this should be called when the user is *in range* of
     * the powerup. Returns the new game state after rolling for the powerup
     */
    async grabPowerup(): Promise<Result<GameState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("grab_powerup") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Game) Use the currently held powerup in the player's held_powerup. Does nothing if the
     * player has none. Returns the updated game state
     */
    async usePowerup(): Promise<Result<GameState, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("use_powerup") };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    },
    /**
     * (Screen: Menu) Check if a room code is valid to join, use this before starting a game
     * for faster error checking.
     */
    async checkRoomCode(code: string): Promise<Result<boolean, string>> {
        try {
            return { status: "ok", data: await TAURI_INVOKE("check_room_code", { code }) };
        } catch (e) {
            if (e instanceof Error) throw e;
            else return { status: "error", error: e as any };
        }
    }
};

/** user-defined events **/

export const events = __makeEvents__<{
    changeScreen: ChangeScreen;
}>({
    changeScreen: "change-screen"
});

/** user-defined constants **/

/** user-defined types **/

export type AppScreen = "Setup" | "Menu" | "Lobby" | "Game";
export type ChangeScreen = AppScreen;
/**
 * Settings for the game, host is the only person able to change these
 */
export type GameSettings = {
    /**
     * The random seed used for shared rng
     */
    random_seed: number;
    /**
     * The number of seconds to wait before seekers are allowed to go
     */
    hiding_time_seconds: number;
    /**
     * Condition to wait for global pings to begin
     */
    ping_start: PingStartCondition;
    /**
     * Time between pings after the condition is met (first ping is either after the interval or
     * instantly after the condition is met depending on the condition)
     */
    ping_minutes_interval: number;
    /**
     * Condition for powerups to start spawning
     */
    powerup_start: PingStartCondition;
    /**
     * Chance every minute of a powerup spawning, out of 100
     */
    powerup_chance: number;
    /**
     * Hard cooldown between powerups spawning
     */
    powerup_minutes_cooldown: number;
    /**
     * Locations that powerups may spawn at
     */
    powerup_locations: Location[];
};
/**
 * This struct handles all logic regarding state updates
 */
export type GameState = {
    /**
     * The id of this player in this game
     */
    id: string;
    /**
     * The powerup the player is currently holding
     */
    held_powerup: PowerUpType | null;
    /**
     * When the game started
     */
    game_started: string;
    /**
     * When seekers were allowed to begin
     */
    seekers_started: string | null;
    /**
     * Last time we pinged all players
     */
    last_global_ping: string | null;
    /**
     * Last time a powerup was spawned
     */
    last_powerup_spawn: string | null;
    /**
     * Hashmap tracking if a player is a seeker (true) or a hider (false)
     */
    caught_state: Partial<{ [key in string]: boolean }>;
    /**
     * A map of the latest global ping results for each player
     */
    pings: Partial<{ [key in string]: PlayerPing }>;
    /**
     * Powerup on the map that players can grab. Only one at a time
     */
    available_powerup: Location | null;
};
export type LobbyState = {
    profiles: Partial<{ [key in string]: PlayerProfile }>;
    join_code: string;
    /**
     * True represents seeker, false hider
     */
    teams: Partial<{ [key in string]: boolean }>;
    self_seeker: boolean;
    settings: GameSettings;
};
/**
 * Some location in the world as gotten from a Geolocation API
 */
export type Location = {
    /**
     * Latitude
     */
    lat: number;
    /**
     * Longitude
     */
    long: number;
    /**
     * The bearing (float normalized from 0 to 1) optional as GPS can't always determine
     */
    heading: number | null;
};
/**
 * The starting condition for global pings to begin
 */
export type PingStartCondition =
    /**
     * Wait For X players to be caught before beginning global pings
     */
    | { Players: number }
    /**
     * Wait for X minutes after game start to begin global pings
     */
    | { Minutes: number }
    /**
     * Don't wait at all, ping location after seekers are released
     */
    | "Instant";
/**
 * An on-map ping of a player
 */
export type PlayerPing = {
    /**
     * Location of the ping
     */
    loc: Location;
    /**
     * Time the ping happened
     */
    timestamp: string;
    /**
     * The player to display as
     */
    display_player: string;
    /**
     * The actual player that initialized this ping
     */
    real_player: string;
};
export type PlayerProfile = { display_name: string; pfp_base64: string | null };
/**
 * Type of powerup
 */
export type PowerUpType =
    /**
     * Ping a random seeker instead of a hider
     */
    | "PingSeeker"
    /**
     * Pings all seekers locations on the map for hiders
     */
    | "PingAllSeekers"
    /**
     * Ping another random hider instantly
     */
    | "ForcePingOther";

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE, Channel as TAURI_CHANNEL } from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
    listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
    once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
    emit: null extends T
        ? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
        : (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> = { status: "ok"; data: T } | { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
    return new Proxy(
        {} as unknown as {
            [K in keyof T]: __EventObj__<T[K]> & {
                (handle: __WebviewWindow__): __EventObj__<T[K]>;
            };
        },
        {
            get: (_, event) => {
                const name = mappings[event as keyof T];

                return new Proxy((() => {}) as any, {
                    apply: (_, __, [window]: [__WebviewWindow__]) => ({
                        listen: (arg: any) => window.listen(name, arg),
                        once: (arg: any) => window.once(name, arg),
                        emit: (arg: any) => window.emit(name, arg)
                    }),
                    get: (_, command: keyof __EventObj__<any>) => {
                        switch (command) {
                            case "listen":
                                return (arg: any) => TAURI_API_EVENT.listen(name, arg);
                            case "once":
                                return (arg: any) => TAURI_API_EVENT.once(name, arg);
                            case "emit":
                                return (arg: any) => TAURI_API_EVENT.emit(name, arg);
                        }
                    }
                });
            }
        }
    );
}
